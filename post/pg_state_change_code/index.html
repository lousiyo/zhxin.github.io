<!DOCTYPE html>
<html lang="zh-cn"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="最近看了PG状态转换的过程,代码细节没有仔细研究，先粗略过了一遍代码，特此记录. PG PG是存储池的基本单元，是一些对象的集合，多副本和纠删的数">  

  <title>
    
      PG Peering过程状态变化代码走读
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.01273a70fa873b012d056499c16bb47955e0e7526c34edb73f05ca8f99f488ebc323423c6557f93f9b42a41de0448a25ce9a1ab577d0bf61e36eaf52a4979a1d.css" integrity="sha512-ASc6cPqHOwEtBWSZwWu0eVXg51JsNO23PwXKj5n0iOvDI0I8ZVf5P5tCpB3gRIolzpoatXfQv2Hjbq9SpJeaHQ==" />
  
</head>
<body a="light">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">返回</a>


<article>
    <p class="post-meta">
        <time datetime="2021-05-28 22:49:38 &#43;0800 CST">
            2021-05-28
        </time>
    </p>

    <h1>PG Peering过程状态变化代码走读</h1>

    

    <p>最近看了PG状态转换的过程,代码细节没有仔细研究，先粗略过了一遍代码，特此记录.</p>
<h3 id="pg">PG</h3>
<p>PG是存储池的基本单元，是一些对象的集合，多副本和纠删的数据备份策略依托PG实现. PG有多种状态，状态之间的变化通过状态机实现.<br>
有两个场景会触发peering流程：</p>
<ul>
<li>在pg创建时</li>
<li>在OSD启动、停止导致OSDMap变化进而导致pg的acting set发生变化时</li>
</ul>
<h3 id="状态机">状态机</h3>
<p>状态机在创建PG进行初始化.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">class</span> <span style="color:#008b45;font-weight:bold">RecoveryMachine</span> : <span style="color:#8b008b;font-weight:bold">public</span> boost::statechart::state_machine&lt; RecoveryMachine, Initial &gt; {
</span></span><span style="display:flex;"><span>    RecoveryState *state;
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    PG *pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    utime_t event_time;
</span></span><span style="display:flex;"><span>    <span style="color:#00688b;font-weight:bold">uint64_t</span> event_count;
</span></span></code></pre></div><p>boost::statechat包含对象：</p>
<ul>
<li>state_machine: 状态机</li>
<li>state: 状态</li>
<li>event：事件 可通过process_event函数进行事件投递</li>
<li>transition / custom_reaction: 转移/反应 custom_reaction通过对于react函数进行处理
PG状态机的对象、状态及时间处理主要在PG.h、PG.cc文件中.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">struct</span> <span style="color:#008b45;font-weight:bold">Initial</span> : boost::statechart::state&lt; Initial, RecoveryMachine &gt;, NamedState {
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">explicit</span> <span style="color:#008b45">Initial</span>(my_context ctx);
</span></span><span style="display:flex;"><span>  <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">exit</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#8b008b;font-weight:bold">typedef</span> boost::mpl::list &lt;
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; Initialize, Reset &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; Load &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; NullEvt &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; boost::statechart::event_base, Crashed &gt;
</span></span><span style="display:flex;"><span> &gt; reactions;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> Load&amp;);
</span></span><span style="display:flex;"><span>     boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> MNotifyRec&amp;);
</span></span><span style="display:flex;"><span>     boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> MInfoRec&amp;);
</span></span><span style="display:flex;"><span>     boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> MLogRec&amp;);
</span></span><span style="display:flex;"><span>     boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> boost::statechart::event_base&amp;) {
</span></span><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">discard_event</span>();
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>   };
</span></span></code></pre></div><p>PG状态机主要包含的状态如下图:<br>
<img src="https://pic.zhxin.xyz//pics/2023/06/08c3c56aa594aab14130362516296b9f.png#center" alt="PG状态机"></p>
<h3 id="primary-peering">Primary Peering</h3>
<p>Primary Peering过程中状态机流程图如下图所示，并没有展示从OSD和Recovery、Backfill过程.<br>
<img src="https://pic.zhxin.xyz//pics/2023/06/d6d4e062eb5a7cbcc50a5a22363f9061.png#center" alt="PG部分状态变化">
主OSD接受到pg_create消息开始创建PG</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> OSD::handle_pg_create(OpRequestRef op)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  MOSDPGCreate *m = (MOSDPGCreate*)op-&gt;get_req();
</span></span><span style="display:flex;"><span>  assert(m-&gt;get_type() == MSG_OSD_PG_CREATE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;handle_pg_create &#34;</span> &lt;&lt; *m &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>依次调用handle_pg_create-&gt; handle_pg_peering_evt -&gt; _create_lock_pg -&gt; _open_lock_pg -&gt; _make_pg,创建PG.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>PG* OSD::_make_pg(
</span></span><span style="display:flex;"><span>  OSDMapRef createmap,
</span></span><span style="display:flex;"><span>  spg_t pgid)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;_open_lock_pg &#34;</span> &lt;&lt; pgid &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>  PGPool pool = _get_pool(pgid.pool(), createmap);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#228b22">// create
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>  PG *pg;
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (createmap-&gt;get_pg_type(pgid.pgid) == pg_pool_t::TYPE_REPLICATED ||
</span></span><span style="display:flex;"><span>      createmap-&gt;get_pg_type(pgid.pgid) == pg_pool_t::TYPE_ERASURE)
</span></span><span style="display:flex;"><span>    pg = <span style="color:#8b008b;font-weight:bold">new</span> ReplicatedPG(&amp;service, createmap, pool, pgid);
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#008b45">assert</span>(<span style="color:#b452cd">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">return</span> pg;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>创建PG完成之后,在handle_pg_create -&gt; handle_pg_peering_evt -&gt; handle_create 函数中,开始进行事件投递和事件的处理.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> PG::handle_create(RecoveryCtx *rctx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;handle_create&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>  rctx-&gt;created_pgs.insert(<span style="color:#8b008b;font-weight:bold">this</span>);
</span></span><span style="display:flex;"><span>  Initialize evt;
</span></span><span style="display:flex;"><span>  recovery_state.handle_event(evt, rctx);
</span></span><span style="display:flex;"><span>  ActMap evt2;
</span></span><span style="display:flex;"><span>  recovery_state.handle_event(evt2, rctx);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在创建之初，状态机处于Initial状态，在此状态下创建一个Initialize事件，状态机的handle_event函数会调用process_event函数将事件投递出去.</p>
<p>可以看到在Initial`状态下接受到Initialize事件之后，状态机直接转换为Reset状态.先调用Reset构造函数,然后带着状态重新回到handle_create函数处，继续创建ActMap事件然后投递出去.<br>
Reset状态下接收到ActMap事件后在对应定义的react函数中进行处理.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>boost::statechart::result PG::RecoveryState::Reset::react(<span style="color:#8b008b;font-weight:bold">const</span> ActMap&amp;)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (pg-&gt;should_send_notify() &amp;&amp; pg-&gt;get_primary().osd &gt;= <span style="color:#b452cd">0</span>) {
</span></span><span style="display:flex;"><span>    context&lt; RecoveryMachine &gt;().send_notify(
</span></span><span style="display:flex;"><span>      pg-&gt;get_primary(),
</span></span><span style="display:flex;"><span>      pg_notify_t(
</span></span><span style="display:flex;"><span> pg-&gt;get_primary().shard, pg-&gt;pg_whoami.shard,
</span></span><span style="display:flex;"><span> pg-&gt;get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span> pg-&gt;get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span> pg-&gt;info),
</span></span><span style="display:flex;"><span>      pg-&gt;past_intervals);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  pg-&gt;update_heartbeat_peers();
</span></span><span style="display:flex;"><span>  pg-&gt;take_waiters();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">return</span> transit&lt; Started &gt;();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在react函数中，状态直接转换到Started状态, Started状态定义了子状态，则直接跳转到Start子状态.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">struct</span> <span style="color:#008b45;font-weight:bold">Started</span> : boost::statechart::state&lt; Started, RecoveryMachine, Start &gt;, NamedState {
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">explicit</span> <span style="color:#008b45">Started</span>(my_context ctx);
</span></span><span style="display:flex;"><span>  <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">exit</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">typedef</span> boost::mpl::list &lt;
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; QueryState &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; AdvMap &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; NullEvt &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; FlushedEvt &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::custom_reaction&lt; IntervalFlush &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; boost::statechart::event_base, Crashed &gt;
</span></span><span style="display:flex;"><span> &gt; reactions;
</span></span><span style="display:flex;"><span>      boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> QueryState&amp; q);
</span></span><span style="display:flex;"><span>      boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> AdvMap&amp;);
</span></span><span style="display:flex;"><span>      boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> FlushedEvt&amp;);
</span></span><span style="display:flex;"><span>      boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> IntervalFlush&amp;);
</span></span><span style="display:flex;"><span>      boost::statechart::result react(<span style="color:#8b008b;font-weight:bold">const</span> boost::statechart::event_base&amp;) {
</span></span><span style="display:flex;"><span> <span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">discard_event</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>查看Start状态的构造函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">/*-------Start---------*/</span>
</span></span><span style="display:flex;"><span>PG::RecoveryState::Start::Start(my_context ctx)
</span></span><span style="display:flex;"><span>  : my_base(ctx),
</span></span><span style="display:flex;"><span>    NamedState(context&lt; RecoveryMachine &gt;().pg-&gt;cct, <span style="color:#cd5555">&#34;Start&#34;</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  context&lt; RecoveryMachine &gt;().log_enter(state_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (pg-&gt;is_primary()) {
</span></span><span style="display:flex;"><span>    dout(<span style="color:#b452cd">1</span>) &lt;&lt; <span style="color:#cd5555">&#34;transitioning to Primary&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>    post_event(MakePrimary());
</span></span><span style="display:flex;"><span>  } <span style="color:#8b008b;font-weight:bold">else</span> { <span style="color:#228b22">//is_stray
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    dout(<span style="color:#b452cd">1</span>) &lt;&lt; <span style="color:#cd5555">&#34;transitioning to Stray&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>    post_event(MakeStray());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先获取当前处理的PG，判断当前osd是不是该pg的主osd，如果是的话则投递MakePrimary事件，否则投递MakeStray事件，如果进入Stray状态则对应PG实例需要由当前Primary按照Peering的进度和结果进一步确认其身份.<br>
按照主OSD的路径继续走, 在Start状态下接受到MakePrimary事件后，状态机会依次进入到Started/Primary/Peering/Getinfo，进入peering阶段。<br>
GetInfo过程获取该PG在其他OSD上的pg_info_t信息。<br>
调用函数generate_past_intervals计算past intervals的值.
调用函数build_prior构造获取pg_info_t信息的OSD列表<br>
调用get_infos给参与的OSD发送获取请求</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">/*--------GetInfo---------*/</span>
</span></span><span style="display:flex;"><span>PG::RecoveryState::GetInfo::GetInfo(my_context ctx)
</span></span><span style="display:flex;"><span>  : my_base(ctx),
</span></span><span style="display:flex;"><span>    NamedState(context&lt; RecoveryMachine &gt;().pg-&gt;cct, <span style="color:#cd5555">&#34;Started/Primary/Peering/GetInfo&#34;</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  context&lt; RecoveryMachine &gt;().log_enter(state_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>  pg-&gt;generate_past_intervals();
</span></span><span style="display:flex;"><span>  unique_ptr&lt;PriorSet&gt; &amp;prior_set = context&lt; Peering &gt;().prior_set;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  assert(pg-&gt;blocked_by.empty());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (!prior_set.get())
</span></span><span style="display:flex;"><span>    pg-&gt;build_prior(prior_set);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  pg-&gt;reset_min_peer_features();
</span></span><span style="display:flex;"><span>  get_infos();
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (peer_info_requested.empty() &amp;&amp; !prior_set-&gt;pg_down) {
</span></span><span style="display:flex;"><span>    post_event(GotInfo());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主OSD收到pg_info的ACK信息后封装成MNotifyRec事件发送给状态机.<br>
在对应react函数中对拉取的pg_info进行处理，在GetInfo状态下如果所有的副本OSD都成功将信息返回，则会投递GotInfo事件.<br>
状态机收到GotInfo事件后，跳转到GetLog状态，在GetLog的构造函数中</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#228b22">/*------GetLog------------*/</span>
</span></span><span style="display:flex;"><span>PG::RecoveryState::GetLog::GetLog(my_context ctx)
</span></span><span style="display:flex;"><span>  : my_base(ctx),
</span></span><span style="display:flex;"><span>    NamedState(
</span></span><span style="display:flex;"><span>      context&lt; RecoveryMachine &gt;().pg-&gt;cct, <span style="color:#cd5555">&#34;Started/Primary/Peering/GetLog&#34;</span>),
</span></span><span style="display:flex;"><span>    msg(<span style="color:#b452cd">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  context&lt; RecoveryMachine &gt;().log_enter(state_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#228b22">// adjust acting?
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>  <span style="color:#8b008b;font-weight:bold">if</span> (!pg-&gt;choose_acting(auth_log_shard, <span style="color:#658b00">false</span>,
</span></span><span style="display:flex;"><span>    &amp;context&lt; Peering &gt;().history_les_bound)) {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">if</span> (!pg-&gt;want_acting.empty()) {
</span></span><span style="display:flex;"><span>      post_event(NeedActingChange());
</span></span><span style="display:flex;"><span>    } <span style="color:#8b008b;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      post_event(IsIncomplete());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>调用choose_acting函数选出具有权威日志的OSD并计算wan_acting列表<br>
如果自己就是权威日志，则不需要拉取，直接投递GotLog事件进入下一状态<br>
如果自己不是权威日志，则需要去具有权威日志的OSD上去拉取，并与本地日志合并.通过发送pg_query_t::LOG事件到具有权威日志的OSD进行拉取,当收到权威日志后，封装成MLogRec类型事件</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>boost::statechart::result PG::RecoveryState::GetLog::react(<span style="color:#8b008b;font-weight:bold">const</span> MLogRec&amp; logevt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  assert(!msg);
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (logevt.from != auth_log_shard) {
</span></span><span style="display:flex;"><span>    dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;GetLog: discarding log from &#34;</span>
</span></span><span style="display:flex;"><span>      &lt;&lt; <span style="color:#cd5555">&#34;non-auth_log_shard osd.&#34;</span> &lt;&lt; logevt.from &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">discard_event</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;GetLog: received master log from osd&#34;</span>
</span></span><span style="display:flex;"><span>    &lt;&lt; logevt.from &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>  msg = logevt.msg;
</span></span><span style="display:flex;"><span>  post_event(GotLog());
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">return</span> <span style="color:#008b45">discard_event</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>投递GotLog事件后，转移到GetMissing状态,进入GetMissing构造函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">/*------GetMissing--------*/</span>
</span></span><span style="display:flex;"><span>PG::RecoveryState::GetMissing::GetMissing(my_context ctx)
</span></span><span style="display:flex;"><span>  : my_base(ctx),
</span></span><span style="display:flex;"><span>    NamedState(context&lt; RecoveryMachine &gt;().pg-&gt;cct, <span style="color:#cd5555">&#34;Started/Primary/Peering/GetMissing&#34;</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  context&lt; RecoveryMachine &gt;().log_enter(state_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>  assert(!pg-&gt;actingbackfill.empty());
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">for</span> (set&lt;pg_shard_t&gt;::iterator i = pg-&gt;actingbackfill.begin();
</span></span><span style="display:flex;"><span>       i != pg-&gt;actingbackfill.end();
</span></span><span style="display:flex;"><span>       ++i) {
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">if</span> (*i == pg-&gt;get_primary()) <span style="color:#8b008b;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">const</span> pg_info_t&amp; pi = pg-&gt;peer_info[*i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">if</span> (pi.is_empty())
</span></span><span style="display:flex;"><span>      <span style="color:#8b008b;font-weight:bold">continue</span>;                                <span style="color:#228b22">// no pg data, nothing divergent
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">if</span> (pi.last_update &lt; pg-&gt;pg_log.get_tail()) {
</span></span><span style="display:flex;"><span>      dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34; osd.&#34;</span> &lt;&lt; *i &lt;&lt; <span style="color:#cd5555">&#34; is not contiguous, will restart backfill&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>      pg-&gt;peer_missing[*i];
</span></span><span style="display:flex;"><span>      <span style="color:#8b008b;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">if</span> (pi.last_backfill == hobject_t()) {
</span></span><span style="display:flex;"><span>      dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34; osd.&#34;</span> &lt;&lt; *i &lt;&lt; <span style="color:#cd5555">&#34; will fully backfill; can infer empty missing set&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>      pg-&gt;peer_missing[*i];
</span></span><span style="display:flex;"><span>      <span style="color:#8b008b;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>GetMissing处理过程中首先拉取各个从OSD的有效日志，然后用主OSD的权威日止与各个从OSD的日志进行对比，从而计算出各个从OSD上不一致的对象并保存在对应的pg_missing_t结构体中，作为后续数据修复依据.<br>
如果所有获取日志的请求都返回并处理完成，则调用Activate(pg-&gt;get_osdmap()-&gt;get_epoch()) 进入Active状态</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#228b22">// all good!
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>post_event(Activate(pg-&gt;get_osdmap()-&gt;get_epoch()));
</span></span></code></pre></div><p>到本阶段则可以说Peering主要工作已经完成,不过在接受客户端读写之前还需要执行active操作激活各个副本，该操作主要目的为固化本地peering成果，以保证其不致因为系统掉电而前功尽弃，同时还需要初始化后续在后台执行Recovery或者Backfill所依赖的关键元数据信息.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>  pg-&gt;activate(*context&lt; RecoveryMachine &gt;().get_cur_transaction(),
</span></span><span style="display:flex;"><span>        pg-&gt;get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>        *context&lt; RecoveryMachine &gt;().get_on_safe_context_list(),
</span></span><span style="display:flex;"><span>        *context&lt; RecoveryMachine &gt;().get_query_map(),
</span></span><span style="display:flex;"><span>        context&lt; RecoveryMachine &gt;().get_info_map(),
</span></span><span style="display:flex;"><span>        context&lt; RecoveryMachine &gt;().get_recovery_ctx());
</span></span></code></pre></div><p>如果所有副本都被激活则投递AllReplicasActivated事件，在Active状态下处理该事件,处理过程中调用pg-&gt;on_activate()函数</p>
<p>在该函数中查看是否需要Recovery需要则触发DoRecovery事件；查看是否需要Backfill操作，需要则触发RequestBackfill操作.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> ReplicatedPG::on_activate()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#228b22">// all clean?
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>  <span style="color:#8b008b;font-weight:bold">if</span> (needs_recovery()) {
</span></span><span style="display:flex;"><span>    dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;activate not all replicas are up-to-date, queueing recovery&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>    queue_peering_event(
</span></span><span style="display:flex;"><span>      CephPeeringEvtRef(
</span></span><span style="display:flex;"><span> std::make_shared&lt;CephPeeringEvt&gt;(
</span></span><span style="display:flex;"><span>   get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>   get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>   DoRecovery())));
</span></span><span style="display:flex;"><span>  } <span style="color:#8b008b;font-weight:bold">else</span> <span style="color:#008b45">if</span> (needs_backfill()) {
</span></span><span style="display:flex;"><span>    dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;activate queueing backfill&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>    queue_peering_event(
</span></span><span style="display:flex;"><span>      CephPeeringEvtRef(
</span></span><span style="display:flex;"><span> std::make_shared&lt;CephPeeringEvt&gt;(
</span></span><span style="display:flex;"><span>   get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>   get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>   RequestBackfill())));
</span></span><span style="display:flex;"><span>  } <span style="color:#8b008b;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    dout(<span style="color:#b452cd">10</span>) &lt;&lt; <span style="color:#cd5555">&#34;activate all replicas clean, no recovery&#34;</span> &lt;&lt; dendl;
</span></span><span style="display:flex;"><span>    queue_peering_event(
</span></span><span style="display:flex;"><span>      CephPeeringEvtRef(
</span></span><span style="display:flex;"><span> std::make_shared&lt;CephPeeringEvt&gt;(
</span></span><span style="display:flex;"><span>   get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>   get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>   AllReplicasRecovered())));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><h3 id="recovery">Recovery</h3>
<p>如果Primary检测自身或者任意一个Peer存在待修复的对象，将通过向状态机投递DoRecovery事件，切换到Started/Primary/Active/WaitLocalRecoveryReserved状态，开始准备执行Recovery.<br>
Recovery 是仅依据PG日志中的缺失记录来修复不一致的对象.<br>
在Activating状态接受到DoRecovery事件后，转换到WaitLocalRecoveryReserved状态.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">struct</span> <span style="color:#008b45;font-weight:bold">Activating</span> : boost::statechart::state&lt; Activating, Active &gt;, NamedState {
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">typedef</span> boost::mpl::list &lt;
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; AllReplicasRecovered, Recovered &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; DoRecovery, WaitLocalRecoveryReserved &gt;,
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; RequestBackfill, WaitLocalBackfillReserved &gt;
</span></span><span style="display:flex;"><span> &gt; reactions;
</span></span><span style="display:flex;"><span>      <span style="color:#8b008b;font-weight:bold">explicit</span> <span style="color:#008b45">Activating</span>(my_context ctx);
</span></span><span style="display:flex;"><span>      <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">exit</span>();
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>在WaitLocalRecoveryReserved构造函数中，通过request_reservation函数进行资源预留请求，资源预留是为了控制一个OSD上正在修复的PG最大数目，在主OSD和从OSD上都需要预约。当收到LocalRecoveryReserved事件后，标志本地资源预约完成.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>PG::RecoveryState::WaitLocalRecoveryReserved::WaitLocalRecoveryReserved(my_context ctx)
</span></span><span style="display:flex;"><span>  : my_base(ctx),
</span></span><span style="display:flex;"><span>    NamedState(context&lt; RecoveryMachine &gt;().pg-&gt;cct, <span style="color:#cd5555">&#34;Started/Primary/Active/WaitLocalRecoveryReserved&#34;</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  context&lt; RecoveryMachine &gt;().log_enter(state_name);
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>  pg-&gt;state_set(PG_STATE_RECOVERY_WAIT);
</span></span><span style="display:flex;"><span>  pg-&gt;osd-&gt;local_reserver.request_reservation(
</span></span><span style="display:flex;"><span>    pg-&gt;info.pgid,
</span></span><span style="display:flex;"><span>    <span style="color:#8b008b;font-weight:bold">new</span> QueuePeeringEvt&lt;LocalRecoveryReserved&gt;(
</span></span><span style="display:flex;"><span>      pg, pg-&gt;get_osdmap()-&gt;get_epoch(),
</span></span><span style="display:flex;"><span>      LocalRecoveryReserved()),
</span></span><span style="display:flex;"><span>    pg-&gt;get_recovery_priority());
</span></span><span style="display:flex;"><span>  pg-&gt;publish_stats_to_osd();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当收到LocalRecoveryReserved事件后，标志本地资源预约完成，然后转移到WaitRemoteRecoveryReserved状态</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#8b008b;font-weight:bold">struct</span> <span style="color:#008b45;font-weight:bold">WaitLocalRecoveryReserved</span> : boost::statechart::state&lt; WaitLocalRecoveryReserved, Active &gt;, NamedState {
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">typedef</span> boost::mpl::list &lt;
</span></span><span style="display:flex;"><span> boost::statechart::transition&lt; LocalRecoveryReserved, WaitRemoteRecoveryReserved &gt;
</span></span><span style="display:flex;"><span> &gt; reactions;
</span></span><span style="display:flex;"><span>      <span style="color:#8b008b;font-weight:bold">explicit</span> <span style="color:#008b45">WaitLocalRecoveryReserved</span>(my_context ctx);
</span></span><span style="display:flex;"><span>      <span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">exit</span>();
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在WaitRemoteRecoveryReserved状态下，完成远程资源的预约，当接收到RemoteRecoveryReserved后表明资源都预约完成，然后投递AllRemotesReserved事件，标志着该PG在所有参与数据修复的从OSD上完成资源预约，进入Recovery状态.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>PG::RecoveryState::Recovering::Recovering(my_context ctx)
</span></span><span style="display:flex;"><span>  : my_base(ctx),
</span></span><span style="display:flex;"><span>    NamedState(context&lt; RecoveryMachine &gt;().pg-&gt;cct, <span style="color:#cd5555">&#34;Started/Primary/Active/Recovering&#34;</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  context&lt; RecoveryMachine &gt;().log_enter(state_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  PG *pg = context&lt; RecoveryMachine &gt;().pg;
</span></span><span style="display:flex;"><span>  pg-&gt;state_clear(PG_STATE_RECOVERY_WAIT);
</span></span><span style="display:flex;"><span>  pg-&gt;state_set(PG_STATE_RECOVERING);
</span></span><span style="display:flex;"><span>  pg-&gt;publish_stats_to_osd();
</span></span><span style="display:flex;"><span>  pg-&gt;osd-&gt;queue_for_recovery(pg);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在Recoverying状态完成实际的数据修复工作<br>
把PG状态设置为PG_STATE_RECOVERING，并把PG添加到recovery_wq工作队列中，开始启动数据修复.<br>
Recovery过程由PG的主OSD来触发并控制，先修复主的，然后修复从的。<br>
在recovery_wq中，工作队列的线程池的处理函数调用do_recovery函数执行实际的数据修复工作.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">void</span> <span style="color:#008b45">_process</span>(PG *pg, ThreadPool::TPHandle &amp;handle) <span style="color:#8b008b;font-weight:bold">override</span> {
</span></span><span style="display:flex;"><span>  osd-&gt;do_recovery(pg, handle);
</span></span><span style="display:flex;"><span>  pg-&gt;put(<span style="color:#cd5555">&#34;RecoveryWQ&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ReplicatedPG::start_recovery_ops函数完成副本类型PG的修复工作.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#eed;-moz-tab-size:2;-o-tab-size:2;tab-size:2;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00688b;font-weight:bold">bool</span> ReplicatedPG::start_recovery_ops(
</span></span><span style="display:flex;"><span>  <span style="color:#00688b;font-weight:bold">int</span> max, ThreadPool::TPHandle &amp;handle,
</span></span><span style="display:flex;"><span>  <span style="color:#00688b;font-weight:bold">int</span> *ops_started)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#00688b;font-weight:bold">int</span>&amp; started = *ops_started;
</span></span><span style="display:flex;"><span>  started = <span style="color:#b452cd">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#00688b;font-weight:bold">bool</span> work_in_progress = <span style="color:#658b00">false</span>;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  started = recover_replicas(max, handle);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#8b008b;font-weight:bold">if</span> (!started) {
</span></span><span style="display:flex;"><span>    <span style="color:#228b22">// We still have missing objects that we should grab from replicas.
</span></span></span><span style="display:flex;"><span><span style="color:#228b22"></span>    started += recover_primary(max, handle);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span></code></pre></div><p>函数ReplicatedPG::recover_primary完成PG主OSD缺失对象的修复<br>
如果在Recoverying状态完成Recovery操作后，如果需要Backfill工作则接受RequestBackfill事件，进入Backfill流程<br>
如果没有Backfill工作，直接接受AllReplicasRecovered事件，转入Recovered状态转入Recovered状态之后，意味着完成数据修复工作，当收到GoClean事件后，PG进入clean状态.</p>
<h3 id="backfill">Backfill</h3>
<p>和Recovery类似，如果Primary发现还有副本需要通过Backfill才能修复，则进行Backfill。<br>
Backfill是PG通过重新扫描所有的对象，对比发现确实的对象，通过整体拷贝来修复。和Recovery一样需要进行资源预约.<br>
这部分过程就不写了&hellip;</p>

</article>

            </div>
        </main>
    </body>
</html>
