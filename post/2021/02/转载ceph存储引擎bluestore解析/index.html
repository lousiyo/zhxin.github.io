<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【转载】ceph存储引擎bluestore解析 | zhxin.xyz</title><meta name=keywords content="ceph"><meta name=description content="转载自sysnote,如有侵权请联系删除 ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，目前默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bl"><meta name=author content><link rel=canonical href=https://zhxin.xyz/post/2021/02/%E8%BD%AC%E8%BD%BDceph%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8Ebluestore%E8%A7%A3%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.025a29662c2e389cf6ace7324d6e1c821f49ebd4fc26062c2c001d1d290d4803.css integrity="sha256-AlopZiwuOJz2rOcyTW4cgh9J69T8JgYsLAAdHSkNSAM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zhxin.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zhxin.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zhxin.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://zhxin.xyz/apple-touch-icon.png><link rel=mask-icon href=https://zhxin.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100;300&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel=stylesheet><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><meta property="og:title" content="【转载】ceph存储引擎bluestore解析"><meta property="og:description" content="转载自sysnote,如有侵权请联系删除 ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，目前默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bl"><meta property="og:type" content="article"><meta property="og:url" content="https://zhxin.xyz/post/2021/02/%E8%BD%AC%E8%BD%BDceph%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8Ebluestore%E8%A7%A3%E6%9E%90/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-02-28T22:49:38+08:00"><meta property="article:modified_time" content="2021-02-28T22:49:38+08:00"><meta property="og:site_name" content="zhxin"><meta name=twitter:card content="summary"><meta name=twitter:title content="【转载】ceph存储引擎bluestore解析"><meta name=twitter:description content="转载自sysnote,如有侵权请联系删除 ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，目前默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bl"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"所有文章","item":"https://zhxin.xyz/post/"},{"@type":"ListItem","position":2,"name":"【转载】ceph存储引擎bluestore解析","item":"https://zhxin.xyz/post/2021/02/%E8%BD%AC%E8%BD%BDceph%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8Ebluestore%E8%A7%A3%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【转载】ceph存储引擎bluestore解析","name":"【转载】ceph存储引擎bluestore解析","description":"转载自sysnote,如有侵权请联系删除 ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，目前默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bl","keywords":["ceph"],"articleBody":"转载自sysnote,如有侵权请联系删除\nceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，目前默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。\nbluestore整体架构 bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是Allocator，目前支持StupidAllocator和BitmapAllocator两种分配器。相关的元数据以kv的形式保存到kv数据库里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是PosixEnv，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。\nbluestore元数据 在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。\n在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。 另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。\nI/O读写映射逻辑 写I/O处理 到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示：\n当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。\ndo_write_big 对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。\ndo_write_small 在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。\n没有找到可以复用的blob，新生成blob 在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。 进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。\n找到可以复用的blob 对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。\na. 直接写在blob未使用的空间上\n这种情况下直接新生成lextent放到blob里。\nb. 覆盖写的情况\n比如下面的这种情况，写I/O会覆盖部分已经写过的数据。\n对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。\n读I/O的处理 读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。\nclone及extent共享 前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode-\u003eblob_map移到onode-\u003ebnode-\u003eblob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode-\u003ebnode指向原对象的onode-\u003ebnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。\n在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。\n小结 本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。\n","wordCount":"3185","inLanguage":"zh","datePublished":"2021-02-28T22:49:38+08:00","dateModified":"2021-02-28T22:49:38+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhxin.xyz/post/2021/02/%E8%BD%AC%E8%BD%BDceph%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8Ebluestore%E8%A7%A3%E6%9E%90/"},"publisher":{"@type":"Organization","name":"zhxin.xyz","logo":{"@type":"ImageObject","url":"https://zhxin.xyz/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://zhxin.xyz/ accesskey=h title="主页 (Alt + H)">主页</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://zhxin.xyz/categories/ title=类别><span><span class=meta-item><i data-feather=grid></i></span>
类别</span></a></li><li><a href=https://zhxin.xyz/tags/ title=标签><span><span class=meta-item><i data-feather=pocket></i></span>
标签</span></a></li><li><a href=https://zhxin.xyz/archives/ title=归档><span><span class=meta-item><i data-feather=archive></i></span>
归档</span></a></li><li><a href=https://zhxin.xyz/search/ title=搜索><span><span class=meta-item><i data-feather=search></i></span>
搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zhxin.xyz/>主页</a>&nbsp;»&nbsp;<a href=https://zhxin.xyz/post/>所有文章</a></div><h1 class=post-title>【转载】ceph存储引擎bluestore解析</h1><div class=post-meta><span class=meta-item><i data-feather=calendar></i>
<span>2021-02-28</span></span><span class=meta-item>
<i data-feather=hash></i>
<a href=https://zhxin.xyz/tags/ceph/>ceph</a></span><span class=meta-item>
<i data-feather=file-text></i>
<span>3185 字</span></span><span class=meta-item>
<i data-feather=clock></i>
<span>7 分钟</span></span>
<script>feather.replace()</script><span class=meta-item><i data-feather=book-open></i>
<span id=busuanzi_value_page_pv></span>
<script>feather.replace()</script></span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#bluestore%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84 aria-label=bluestore整体架构>bluestore整体架构</a></li><li><a href=#bluestore%e5%85%83%e6%95%b0%e6%8d%ae aria-label=bluestore元数据>bluestore元数据</a></li><li><a href=#io%e8%af%bb%e5%86%99%e6%98%a0%e5%b0%84%e9%80%bb%e8%be%91 aria-label=I/O读写映射逻辑>I/O读写映射逻辑</a><ul><li><a href=#%e5%86%99io%e5%a4%84%e7%90%86 aria-label=写I/O处理>写I/O处理</a><ul><li><a href=#do_write_big aria-label=do_write_big>do_write_big</a></li><li><a href=#do_write_small aria-label=do_write_small>do_write_small</a></li></ul></li><li><a href=#%e8%af%bbio%e7%9a%84%e5%a4%84%e7%90%86 aria-label=读I/O的处理>读I/O的处理</a></li></ul></li><li><a href=#clone%e5%8f%8aextent%e5%85%b1%e4%ba%ab aria-label=clone及extent共享>clone及extent共享</a></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></div></details></div><div class=post-content><p><em><strong>转载自<a href=https://sysnote.github.com/>sysnote</a>,如有侵权请联系删除</strong></em></p><p>ceph后端支持多种存储引擎，以插件式的方式来进行管理使用，目前支持filestore，kvstore，memstore以及最新的bluestore，目前默认使用的filestore，但是因为filestore在写数据前需要先写journal，会有一倍的写放大，并且filestore一开始只是对于机械盘进行设计的，没有专门针对ssd做优化考虑，因此诞生的bluestore初衷就是为了减少写放大，并针对ssd做优化，而且直接管理裸盘，从理论上进一步减少文件系统如ext4/xfs等部分的开销，目前bluestore还处于开发优化阶段，在jewel版本还是试用版本，并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。本文基于master分支对bluestore存储引擎进行分析。</p><h2 id=bluestore整体架构>bluestore整体架构<a hidden class=anchor aria-hidden=true href=#bluestore整体架构>#</a></h2><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/e021387c4c0fc5141ae7e2cd2d67972f.png#center alt=arch></p><p>bluestore直接管理裸设备，抛弃了ext4/xfs等本地文件系统，BlockDevice实现在用户态下使用linux aio直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理，对应的就是Allocator，目前支持StupidAllocator和BitmapAllocator两种分配器。相关的元数据以kv的形式保存到kv数据库里，默认使用的是rocksdb，由于rocksdb本身是基于文件系统的，不是直接操作裸设备，但是rocksdb也比较灵活，将系统相关的处理抽象成Env，用户可用实现相应的接口，rocksdb默认的Env是PosixEnv，直接对接本地文件系统，为此，bluestore实现了一个BlueRocksEnv，继承自EnvWrapper，来为rocksdb提供底层系统的封装，为了对接BlueRocksEnv，实现了一个小的文件系统BlueFS，只实现rocksdb Env需要的接口，在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。</p><h2 id=bluestore元数据>bluestore元数据<a hidden class=anchor aria-hidden=true href=#bluestore元数据>#</a></h2><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/c095dab2aa4269f667afc05075088efe.png#center alt=metadata></p><p>在之前的存储引擎filestore里，对象的表现形式是对应到文件系统里的文件，默认4MB大小的文件，但是在bluestore里，已经没有传统的文件系统，而是自己管理裸盘，因此需要有元数据来管理对象，对应的就是Onode，Onode是常驻内存的数据结构，持久化的时候会以kv的形式存到rocksdb里。</p><p>在onode里又分为lextent，表示逻辑的数据块，用一个map来记录，一个onode里会存在多个lextent，lextent通过blob的id对应到blob（bluestore_blob_t ），blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。
另外还有Bnode这个元数据，它是用来表示多个object可能共享extent，目前在做了快照后写I/O触发的cow进行clone的时候会用到。</p><h2 id=io读写映射逻辑>I/O读写映射逻辑<a hidden class=anchor aria-hidden=true href=#io读写映射逻辑>#</a></h2><h3 id=写io处理>写I/O处理<a hidden class=anchor aria-hidden=true href=#写io处理>#</a></h3><p>到达bluestore的I/O的offset和length都是对象内（onode）的，offset是相对于这个对象起始位置的偏移，在_do_write里首先就会根据最小分配单位min_alloc_size进行判断，从而将I/O分为对齐和非对齐的。如下图所示：</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/e994e2526615312d42af6f22315317ac.png#center alt=iosplit></p><p>当一个写请求按照min_alloc_size进行拆分后，就会分为对齐写，对应到do_write_big，非对齐写（即落到某一个min_alloc_size区间的写I/O（对应到do_write_small）。</p><h4 id=do_write_big>do_write_big<a hidden class=anchor aria-hidden=true href=#do_write_big>#</a></h4><p>对齐到min_alloc_size的写请求处理起来比较简单，有可能是多个min_alloc_size的大小，在处理时会根据实际大小新生成lextent和blob，这个lextent跨越的区域是min_alloc_size的整数倍，如果这段区间是之前写过的，会将之前的lextent记录下来便于后续的空间回收。</p><h4 id=do_write_small>do_write_small<a hidden class=anchor aria-hidden=true href=#do_write_small>#</a></h4><p>在处理落到某个min_alloc_size区间的写请求时，会首先根据offset去查找有没有可以复用的blob，因为最小分配单元是min_alloc_size，默认64KB，如果一个4KB的写I/O就只会用到blob的一部分，blob里剩余的还能放其他的。</p><ol><li>没有找到可以复用的blob，新生成blob
在处理还还需要根据offset和len是否对齐到block_size（默认是4KB）进行补零对齐的操作，之所以需要补齐是与后续的写盘操作有关，真正写盘时有两种方式，一种是Direct I/O的方式，这种要求偏移和缓冲区都对齐的，另外一种非Direct I/O，即Buffered I/O，这种可以不对齐，但是是写到cache里，然后再sync刷到磁盘上，比如只写了100字节，在内核里是需要先从设备上读出来补齐成一个完整的扇区，然后再刷的，这样反而降低了效率。因此在bluestore里直接处理好对齐，对于后面的写盘来说比较有利，这里对齐到block_size，是个可配置的参数。</li></ol><p>进行对齐补零时就是按照如上图那样把前后对齐到block_size，然后再把对齐后的offset和len作为lextent，进而放到blob里。</p><ol start=2><li>找到可以复用的blob</li></ol><p>对于可以复用的blob，也是先按照block_size进行对齐补零的动作，然后再判断是否可以直接使用blob里空闲的空间进行区分做不同的处理。</p><p>a. <strong>直接写在blob未使用的空间上</strong></p><p>这种情况下直接新生成lextent放到blob里。</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/eaa4b73efd7c5591a0703b5d2cd78eb7.png#center alt=writetoblob></p><p>b. <strong>覆盖写的情况</strong></p><p>比如下面的这种情况，写I/O会覆盖部分已经写过的数据。</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/a64c4a39bdf2f6d0faaf3c149d7619c7.png#center alt=overwrite></p><p>对于这种情况的处理如下图：也是需要先处理对齐补零的情况，如果覆盖的区域刚好是已经对齐到block_size，那么就不需要从磁盘读数据，但是如果覆盖的区域没有对齐到block_size，那么就需要把不对齐的那部分读出来，拼成一个对齐的buffer，然后新生成lextent，并且会对原来那个lextent进行调整，会记录需要回收的那部分区域。对于覆盖写的情况，都不是直接写盘，而是通过wal写到rocksdb。</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/e93324b86dc9771617b72c9e816efdb2.png#center alt=overwrite_wal></p><h3 id=读io的处理>读I/O的处理<a hidden class=anchor aria-hidden=true href=#读io的处理>#</a></h3><p>读I/O请求的处理时也是通过寻找相关联的lextent，可能会存在空洞的情况，即读到未写过的数据，这部分就直接补零。</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/dd870e1fafe234713e861be85e70be30.png#center alt=readio></p><h2 id=clone及extent共享>clone及extent共享<a hidden class=anchor aria-hidden=true href=#clone及extent共享>#</a></h2><p>前面说到Bnode就是用来记录共享的lextent，目前是在做完快照后对原卷进行写I/O会触发cow，从而产生clone操作。clone时就是将原对象的blob从onode->blob_map移到onode->bnode->blob_map，并且将blob id置为负的，并设置共享标记，然后将新的快照对象的onode->bnode指向原对象的onode->bnode，并且用原onode里的lextents里的值赋给新的onode的lextents，从而达到共享extent的目的，图示仅供参考。</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/bbf588d87d1650d112160665e8f378da.png#center alt=clone></p><p>在clone完之后，继续对原对象进行写I/O操作时，当碰到共享的blob时就需要跳过，新生成blob，并且取消对原来那部分lextent的引用，在后续的空间释放时的判断依据就是否还有引用。</p><p><img loading=lazy src=https://pic.zhxin.xyz//pics/2023/06/138593573876b1ee1ab456d5d6877138.png#center alt=cloneio></p><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>本文总体上介绍了bluestore的架构、相关元数据及内部I/O映射的逻辑，这还只是bluestore的冰山一角，后续会陆续对bluestore的处理流程、空间分配器、缓存管理、压缩等实现进行分析。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zhxin.xyz/tags/ceph/>ceph</a></li></ul><nav class=paginav><a class=prev href=https://zhxin.xyz/post/2021/03/git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/><span class=title>« 上一页</span><br><span>Git 基本操作</span></a>
<a class=next href=https://zhxin.xyz/post/2021/02/%E5%B8%B8%E7%94%A8ceph%E5%91%BD%E4%BB%A4/><span class=title>下一页 »</span><br><span>常用ceph命令</span></a></nav></footer></article></main><footer class=footer><span class=bs-item><span id=busuanzi_container_site_pv></span><i data-feather=eye> </i><span id=busuanzi_value_site_pv></span></span>
<span class=bs-item><span id=busuanzi_container_site_uv></span><i data-feather=user> </i><span id=busuanzi_value_site_uv></span></span><br><span><a href=https://zhxin.xyz/>zhxin.xyz</a> &copy; 2023 Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo &</a>
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>feather.replace();let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>